import argparse
import datetime
import multiprocessing as mp
import os
import utilities
import shutil


class ExecConfiguration:
    def __init__(self):
        self.config = None


class DateConfig:
    def __init__(self, date_str):
        self.date_with_slash = date_str
        self.date_with_hyphen = date_str.replace('/', '-')

    def slash(self):
        return self.date_with_slash

    def hyphen(self):
        return self.date_with_hyphen


def run_simulation(command_str):
    # Measure simulation duration
    start_simulation = datetime.datetime.now()
    # Call simulation
    process = os.popen(command_str)
    print(process.read())
    process.close()
    # Compute elapsed time and update total simulation time
    end_simulation = datetime.datetime.now()
    elapsed_time = end_simulation - start_simulation
    utilities.safe_print('\tCommand:' + command_str + ' \n\t\tElapsed:' + '%.2f seconds' % elapsed_time.total_seconds())
    return elapsed_time.total_seconds()


# total simulation time for the record
total_simulations_time = 0
total_simulations_run = 0


def sum_simulation_time(result):
    global total_simulations_time
    global total_simulations_run
    total_simulations_time += int(result)
    total_simulations_run += 1


def simulation_error(error):
    utilities.safe_print(error)


def to_normalize_path(path):
    return r'"%s"' % path


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Cold storage simulation.')
    parser.add_argument('--exe', type=str, help='Path of the VarroaPop command line application', required=True)
    parser.add_argument('--vrp', type=str, help='Path of the vrp file to use for simulations', required=True)
    parser.add_argument('--output_directory', type=str,
                        help='Output files will be written in an autogenerated folder within OUT_DIR',
                        metavar='OUT_DIR', required=True)
    parser.add_argument('--input_directory', type=str, help='Input directory expecting IN_DIR/SCENARIO.txt',
                        metavar='IN_DIR', required=True)
    parser.add_argument('--weather_directory', type=str, help='Get weather files from WEATHER_DIRECTORY',
                        metavar='WEATHER_DIRECTORY', required=True)
    parser.add_argument('--snapshots_directory', type=str, help='Get snapshots files from SNAPSHOTS_DIRECTORY',
                        metavar='SNAPSHOTS_DIRECTORY', required=False)
    parser.add_argument('--skip_default', type=bool, help='Skip the simulation without cold storage',
                        metavar='SKIP_DEFAULT', default=False)
    arguments = parser.parse_args()

    print('Working directory: ' + os.getcwd())

    if not os.path.isfile(arguments.exe):
        print('Cannot find VarroaPop executable at: ' + arguments.exe)
        exit(-1)

    if not os.path.isfile(arguments.vrp):
        print('Cannot find VRP file at: ' + arguments.vrp)
        exit(-1)

    if os.path.isfile(arguments.output_directory):
        print(arguments.output_directory + ' is not a directory')
        exit(-1)

    if not os.path.isdir(arguments.input_directory):
        print('Cannot find input directory at: ' + arguments.input_directory)
        exit(-1)

    if not os.path.isdir(arguments.weather_directory):
        print('Cannot find weather directory at: ' + arguments.weather_directory)
        exit(-1)

    # start_dates = []
    # end_dates = []

    start_dates = [
        DateConfig('10/15')]

    end_dates = [
        DateConfig('01/31'),
        DateConfig('04/01')]

    exec_configurations = []

    default_command = arguments.exe + ' -f -v ' + to_normalize_path(arguments.vrp) + \
                      ' --forageDayNoTemp --hourlyTemperaturesEstimation --foragersAlwaysAgeBasedOnForageInc' + \
                      ' --adultAgingBasedOnLaidEggs  --inOutEvents'

    if os.path.isdir(arguments.snapshots_directory):
        default_command += ' -s ' + arguments.snapshots_directory

    input_files_exists = {}

    # one setting for each location
    snapshots_auto = {
        'Omak': "snapshot-omak-inmcm4-1983",
        'Richland': "snapshot-richland-bcc-csm1-1-m-1976",
        'Walla Walla': "snapshot-wallawalla-hadgem2-cc365-1975",
        'Wenatchee': "snapshot-wenatchee-bcc-csm1-1-m-1992"
    }

    # same setting for every locations
    snapshots_auto = {
        'Omak': "snapshot-autoreset-omak-ccsm4-2001",
        'Richland': "snapshot-autoreset-omak-ccsm4-2001",
        'Walla Walla': "snapshot-autoreset-omak-ccsm4-2001",
        'Wenatchee': "snapshot-autoreset-omak-ccsm4-2001"
    }

    snapshots_init_year = {
        'modeled': "1950",
        'rcp45': "2006",
        'rcp85': "2006"
    }

    # gather configurations for simulations
    weather_files = os.listdir(arguments.weather_directory)
    for weather_file in weather_files:
        if weather_file.startswith('.'):
            continue

        info = utilities.parse_weather_filename(weather_file)
        location_output_directory = os.path.join(arguments.output_directory, info.location)
        output_directory = os.path.join(location_output_directory, info.scenario)

        # get input filename and check if it exists
        input_file = os.path.join(arguments.input_directory, info.scenario + '.txt')
        if not input_file in input_files_exists:
            input_files_exists[input_file] = os.path.exists(input_file)
        if not input_files_exists[input_file]:
            print('Missing input file ' + input_file)
            exit(-1)

        if not os.path.exists(location_output_directory):
            os.makedirs(location_output_directory)

        location_input_file = os.path.join(location_output_directory, info.scenario + '.txt')
        if not os.path.exists(location_input_file):
            shutil.copy(input_file, location_input_file)
            with open(location_input_file, 'a+') as file:
                file.writelines(
                    ['CREnabled=True\n',
                     'CRResetScheduled=False\n',
                     'CRResetDate=01/01/'+snapshots_init_year[info.scenario]+'\n',
                     'CRResetName=snapshot-initial-omak-ccsm4-2001\n',
                     'CRResetScheduled=True\n',
                     'CRResetDate=06/15/'+snapshots_init_year[info.scenario]+'\n',
                     'CRResetName='+snapshots_auto[info.location]+'\n'])

        command = default_command + ' -i ' + to_normalize_path(location_input_file)
        command += ' -w ' + to_normalize_path(os.path.join(arguments.weather_directory, weather_file))
        command += ' --binaryWeatherFileFormat ' + utilities.get_valid_binary_format_identifier(info.scenario)

        # output only colony size
        # command += ' --outputFormat colony'

        # output age structure
        command += ' --outputFormat age_structure'

        # compress output into a GZ file
        command += ' --compress'

        # add configuration without cold storage
        if not arguments.skip_default:
            output_filename = info.model + '_default'
            output_file = os.path.join(output_directory, output_filename + '.csv')
            exec_command = command + ' -o ' + to_normalize_path(output_file)
            exec_configurations.append(exec_command)

        # add configurations for cold storage
        for start_date in start_dates:
            for end_date in end_dates:
                output_filename = info.model + '_cold_storage_' + start_date.hyphen() + '_' + end_date.hyphen()
                output_file = os.path.join(output_directory, output_filename + '.csv')
                exec_command = command + ' -o ' + to_normalize_path(output_file)
                exec_command += ' --coldStorage --coldStorageStartDate %s --coldStorageEndDate %s' \
                                % (start_date.slash(), end_date.slash())
                exec_configurations.append(exec_command)

    # run simulations
    print('Executing Simulations: ')
    simulation_time = datetime.datetime.now()

    # Step 1: Init multiprocessing.Pool()
    pool = mp.Pool(mp.cpu_count())

    # Step 2: Use loop to parallelize
    for configuration in exec_configurations:
        pool.apply_async(run_simulation,
                         args=(configuration,),
                         callback=sum_simulation_time,
                         error_callback=simulation_error)

    # Step 3: Don't forget to close
    pool.close()

    # Step 4: Wait for processes to complete
    pool.join()

    print('Total duration             (s):' + '%.2f' % (datetime.datetime.now() - simulation_time).total_seconds())
    print('Total duration accumulated (s):' + '%.2f' % total_simulations_time)
    print('Total simulations executed    :' + '%d' % total_simulations_run)
